"""
PlantUML Generator for OWL Ontologies

This module generates PlantUML class diagrams from OWL ontologies, representing
the class hierarchy, object properties, and other ontological relationships.
"""

import os
import logging
import plantuml
import tempfile
from urllib.parse import quote

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class PlantUMLGenerator:
    """
    A class to generate PlantUML diagrams from OWL ontologies.
    """
    
    def __init__(self, plantuml_server="http://www.plantuml.com/plantuml"):
        """
        Initialize the PlantUML generator.
        
        Args:
            plantuml_server (str): URL of the PlantUML server
        """
        self.plantuml = plantuml.PlantUML(url=plantuml_server)
        self.static_folder = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static')
        os.makedirs(os.path.join(self.static_folder, 'diagrams'), exist_ok=True)
        
    def generate_class_diagram(self, ontology, filename_base, include_individuals=False, 
                              include_data_properties=True, include_annotation_properties=False,
                              max_classes=100):
        """
        Generate a PlantUML class diagram from an ontology.
        
        Args:
            ontology: The loaded Owlready2 ontology
            filename_base (str): Base filename for saving the diagram
            include_individuals (bool): Whether to include individuals in the diagram
            include_data_properties (bool): Whether to include data properties
            include_annotation_properties (bool): Whether to include annotation properties
            max_classes (int): Maximum number of classes to include in the diagram
            
        Returns:
            tuple: (plantuml_code, diagram_path, svg_path)
        """
        logger.info(f"Generating class diagram for ontology {ontology.name}")
        
        # Generate PlantUML code
        plantuml_code = self._generate_plantuml_code(
            ontology, 
            include_individuals=include_individuals,
            include_data_properties=include_data_properties,
            include_annotation_properties=include_annotation_properties,
            max_classes=max_classes
        )
        
        # Generate and save the diagram
        diagram_path = os.path.join('static', 'diagrams', f"{filename_base}.png")
        svg_path = os.path.join('static', 'diagrams', f"{filename_base}.svg")
        
        # Save full path to file system
        full_diagram_path = os.path.join(self.static_folder, 'diagrams', f"{filename_base}.png")
        full_svg_path = os.path.join(self.static_folder, 'diagrams', f"{filename_base}.svg")
        
        # Save PlantUML source
        plantuml_path = os.path.join(self.static_folder, 'diagrams', f"{filename_base}.plantuml")
        with open(plantuml_path, 'w') as f:
            f.write(plantuml_code)
            
        # Generate diagrams
        try:
            self.plantuml.processes(plantuml_code, outfile=full_diagram_path)
            self.plantuml.processes_file(plantuml_path, outfile=full_svg_path, pipetype="svg")
            logger.info(f"Generated diagram: {diagram_path}")
        except Exception as e:
            logger.error(f"Error generating diagram: {str(e)}")
            return plantuml_code, None, None
        
        return plantuml_code, diagram_path, svg_path
        
    def _generate_plantuml_code(self, ontology, include_individuals=False, 
                               include_data_properties=True, include_annotation_properties=False,
                               max_classes=100):
        """
        Generate PlantUML code for a class diagram from an ontology.
        
        Args:
            ontology: The loaded Owlready2 ontology
            include_individuals (bool): Whether to include individuals in the diagram
            include_data_properties (bool): Whether to include data properties
            include_annotation_properties (bool): Whether to include annotation properties
            max_classes (int): Maximum number of classes to include in the diagram
            
        Returns:
            str: PlantUML code
        """
        # Start with PlantUML header
        uml_code = [
            "@startuml",
            "' Ontology Class Diagram",
            f"' Ontology: {ontology.name}",
            "' Generated by FOL-BFO-OWL Tester",
            "",
            "' Use dark blue theme",
            "!theme cerulean-outline",
            "",
            "' Styling options",
            "skinparam class {",
            "  BackgroundColor<<BFO>> LightBlue",
            "  BorderColor<<BFO>> DarkBlue",
            "  BackgroundColor<<Domain>> LightGreen",
            "  BorderColor<<Domain>> DarkGreen",
            "  BackgroundColor<<Individual>> White",
            "  BorderColor<<Individual>> Gray",
            "}",
            "",
            "' Class definitions"
        ]
        
        # Process classes (limit to max_classes)
        classes = list(ontology.classes())[:max_classes]
        
        # Track processed classes to avoid duplicates
        processed_classes = set()
        
        # Process class hierarchy
        for cls in classes:
            if cls in processed_classes:
                continue
                
            processed_classes.add(cls)
            
            # Determine stereotype
            if "BFO" in cls.iri or "IAO" in cls.iri:
                stereotype = "<<BFO>>"
            else:
                stereotype = "<<Domain>>"
                
            # Add class definition
            class_name = self._sanitize_name(cls.name)
            uml_code.append(f"class \"{class_name}\" {stereotype}")
            
            # Add data properties if requested
            if include_data_properties:
                for prop in cls.get_class_properties():
                    # Skip object properties, handle later
                    if hasattr(prop, 'range') and prop.range and len(prop.range) > 0 and prop.range[0] in classes:
                        continue
                        
                    if hasattr(prop, 'name') and prop.name:
                        prop_name = self._sanitize_name(prop.name)
                        uml_code.append(f"\"{class_name}\" : +{prop_name}")
            
            # Add parents
            for parent in cls.is_a:
                if hasattr(parent, 'name') and parent.name and parent in classes:
                    parent_name = self._sanitize_name(parent.name)
                    uml_code.append(f"\"{parent_name}\" <|-- \"{class_name}\"")
        
        # Process object properties
        uml_code.append("\n' Object properties")
        relations = set()
        
        for cls in classes:
            for prop in cls.get_class_properties():
                # Check if this is an object property
                if hasattr(prop, 'range') and prop.range and len(prop.range) > 0 and prop.range[0] in classes:
                    for range_cls in prop.range:
                        if range_cls in classes:
                            source = self._sanitize_name(cls.name)
                            target = self._sanitize_name(range_cls.name)
                            rel_name = self._sanitize_name(prop.name)
                            
                            relation = f"\"{source}\" --> \"{target}\" : {rel_name}"
                            if relation not in relations:
                                relations.add(relation)
                                uml_code.append(relation)
        
        # Process individuals if requested
        if include_individuals:
            uml_code.append("\n' Individuals")
            
            for cls in classes:
                individuals = list(cls.instances())
                
                for individual in individuals:
                    if hasattr(individual, 'name') and individual.name:
                        ind_name = self._sanitize_name(individual.name)
                        class_name = self._sanitize_name(cls.name)
                        
                        uml_code.append(f"object \"{ind_name}\" <<Individual>>")
                        uml_code.append(f"\"{class_name}\" <.. \"{ind_name}\" : instance")
        
        # Add PlantUML footer
        uml_code.append("\n@enduml")
        
        return "\n".join(uml_code)
    
    def _sanitize_name(self, name):
        """Sanitize names for PlantUML by removing problematic characters."""
        if name is None:
            return "Unknown"
            
        # Replace problematic characters
        return name.replace("#", "_").replace(":", "_").replace("'", "").replace("\"", "")